{% extends 'base.md.j2' %}
{% block lead_paragraph %}

This post is all about getting your machine ready to run itself. I've tried to actually explain everything that went into the configuration, which was very useful to me and hopefully offers something to you. I provide a general Linux approach, a tested Nginx configuration, and some Apache stuff I researched because I'll probably have to support that at work.

{% endblock %}
{% block content %}

## Prototypical Resources

I've been shuffling around copypasta Let's Encrypt config since, I think, the middle of last year (the company's only 19 months old, so it couldn't have been much longer than that). I don't have VCS versions of any of that, so unfortunately I can't point to a single article or book that shaped this. This list deserves highlighting if for no other reason than I had the link saved and totally forgot where I was going to use it.

* [This Gist](https://gist.github.com/cecilemuller/a26737699a7e70a7093d4dc115915de8) is a great resource to snag a stable config you can put almost anywhere.
* [This Gist](https://gist.github.com/AndreiD/3d4b36c58fa59c8ec1ef98276eacb636) is another great resouce. I believe I've had portions of it in production at some point.
* [Qualys SSL Labs](https://www.ssllabs.com/) is the SSL gold standard. If you don't have a good Qualys rating, you don't have a good config.
* Mozilla provides [a great generator](https://mozilla.github.io/server-side-tls/ssl-config-generator/) that's probably responsible for a fair chunk of the articles out there now.

## `certbot`

You can follow distro-specific instructions [via the official docs](https://certbot.eff.org/docs/install.html) for [almost everything](https://certbot.eff.org/docs/install.html#operating-system-packages). [The generic `wget` method](https://certbot.eff.org/docs/install.html#certbot-auto) usually provides the most current version; however, it's usually a better idea to wait for an official package.

{{ highlight_block("""\
$ wget https://dl.eff.org/certbot-auto
$ wget -N https://dl.eff.org/certbot-auto.asc
$ gpg2 --recv-key A2CFB51FA275A7286234E7B24D17C995CD9775F2
$ gpg2 --trusted-key 4D17C995CD9775F2 --verify certbot-auto.asc certbot-auto
$ chmod a+x ./certbot-auto
$ sudo mv ./certbot-auto /usr/bin/certbot-auto
""",
linenos = False,
explicit_lexer_name = 'BashSessionLexer',
no_header = True
) }}

## Common Let's Encrypt Elements

Let's Encrypt works by creating challenges on the server and verifying them through an external request. To simplify things, it's a good idea to create a centralized location for everything. With one or two sites, it's not a huge deal; it's very nice the more sites your server supports.

I prefer [the `/srv` directory](http://refspecs.linuxfoundation.org/FHS_2.3/fhs-2.3.html#SRVDATAFORSERVICESPROVIDEDBYSYSTEM) over [the `/var` directory](http://refspecs.linuxfoundation.org/FHS_2.3/fhs-2.3.html#THEVARHIERARCHY), YMMV.

{{
    shell_session("""\
$ sudo groupadd letsencrypt
$ sudo mkdir -p /srv/www/letsencrypt/.well-known/acme-challenge
$ sudo chown -R :letsencrypt /srv/www/letsencrypt
$ sudo chmod g+rwx /srv/www/letsencrypt
"""
    )
}}

We'll also want to save a snippet dropping the webserver here.

### Nginx

This is just a simple location block.

{{
    highlight_block("""\
location ^~ /.well-known/acme-challenge/ {
    default_type \"text/plain\";
    root /srv/www/letsencrypt;
}
""",
        explicit_lexer_name = 'NginxConfLexer',
        title = '/etc/nginx/common/letsencrypt.conf'
    )
}}

I've got at least three servers running a variant of this right now.

### Apache

From [the Let's Encrypt forums](https://community.letsencrypt.org/t/apache-multidomain-webroot/10663/2),

{{
    highlight_block("""\
Alias /.well-known/acme-challenge/ /srv/www/letsencrypt/.well-known/acme-challenge/
<Directory \"/srv/www/letsencrypt/.well-known/acme-challenge/\">
    Options None
    AllowOverride None
    ForceType text/plain
    RedirectMatch 404 \"^(?!/\.well-known/acme-challenge/[\w-]{43}$)\"
</Directory>
""",
        explicit_lexer_name = 'ApacheConfLexer',
        title = '/etc/httpd/common/letsencrypt.conf'
    )
}}

I have not tested this.

## Generic SSL Config

I'll be using [the Qualys suggested configuration](https://github.com/ssllabs/research/wiki/SSL-and-TLS-Deployment-Best-Practices) to set this up. Most of this stuff is explained elsewhere on the internet. I wanted to grok the whole process, so I wrote it up.

## Location

This creates a single file to hold the common config.

### Nginx

1. I don't like common configuration cluttering up the normal directories.
2. Basically everyone you ask will suggest a different directory for common config.
3. I like `/etc/nginx/common`.

{{
    shell_session("""\
$ sudo touch /etc/nginx/common/ssl.conf
"""
    )
}}

### Apache

So this probably won't work without some TLC. Apache differentiates global vs scoped config, and some of the things I mention only work in one or the other. However, I'm going to pretend like it will work without issue and hope no one notices.

{{
    shell_session("""\
$ sudo touch /etc/httpd/common/ssl.conf
"""
    )
}}

You'll also need to ensure you've got the right modules installed and running. Depending [on your server's distro](https://askubuntu.com/a/600902) and the version of Apache you're running, installing and enabling modules is done differently.

{{
    shell_session("""\
$ which a2enmod && echo \"apache2\" || echo \"httpd\"
RHEL is usually httpd
Debian is usually apache2
"""
    )
}}

* If you're running `httpd`, enable them by editing `/etc/httpd/conf.modules.d/00-base.conf`.
* If you're running `apache2`, enable them via `a2enmod`.

You'll need these modules:

* `mod_rewrite`
* `mod_ssl`
* `mod_socache_shmcb` for any caching (sessions, stapling)

{{
    shell_session("""\
$ eval \"$(which apachectl && echo apachectl || echo httpd) -M\" | grep -E \"rewrite|ssl|socache\"
 authn_socache_module (shared)
 rewrite_module (shared)
 socache_dbm_module (shared)
 socache_memcache_module (shared)
 socache_shmcb_module (shared)
 ssl_module (shared)
"""
    )
}}

## Specify Allowed TLS Versions

Qualys says [`v1.2` is the only secure version](https://github.com/ssllabs/research/wiki/SSL-and-TLS-Deployment-Best-Practices#22-use-secure-protocols). If you're truly desperate, `v1.1` isn't too bad. Don't forget that Qualys writes the benchmark, so if you ignore that advice, your rating will take a hit.

### Nginx

{{
    highlight_block("""\
ssl_protocols TLSv1.2;
""",
        explicit_lexer_name = 'NginxConfLexer',
        no_header = True
    )
}}

### Apache

{{
    highlight_block("""\
SSLProtocol -all +TLSv1.2
""",
        explicit_lexer_name = 'ApacheConfLexer',
        no_header = True
    )
}}

#### Generate a List of Good Ciphers

You might check [the current list](https://github.com/ssllabs/research/wiki/SSL-and-TLS-Deployment-Best-Practices#23-use-secure-cipher-suites) to make sure this is up-to-date. You can also shorten this list; I was curious how it was built.

{{
    highlight_block("""\
ECDHE-ECDSA-AES128-GCM-SHA256
ECDHE-ECDSA-AES256-GCM-SHA384
ECDHE-ECDSA-AES128-SHA
ECDHE-ECDSA-AES256-SHA
ECDHE-ECDSA-AES128-SHA256
ECDHE-ECDSA-AES256-SHA384
ECDHE-RSA-AES128-GCM-SHA256
ECDHE-RSA-AES256-GCM-SHA384
ECDHE-RSA-AES128-SHA
ECDHE-RSA-AES256-SHA
ECDHE-RSA-AES128-SHA256
ECDHE-RSA-AES256-SHA384
DHE-RSA-AES128-GCM-SHA256
DHE-RSA-AES256-GCM-SHA384
DHE-RSA-AES128-SHA
DHE-RSA-AES256-SHA
DHE-RSA-AES128-SHA256
DHE-RSA-AES256-SHA256
""",
        explicit_lexer_name = 'TextLexer',
        title = '/save/the/qualys/list/somewhere'
    )
}}

We can use `grep` to search with a pattern from a `-f`ile, composed of newline-separated `-F`ixed strings, where each pattern matches the entire line (`-x`). All we need is the available ciphers. `openssl ciphers` returns a colon-separated list, so we can pass it through `tr`anslate before searching it.

{{
    shell_session("""\
$ grep -Fx -f /save/the/qualys/list/somewhere <( openssl ciphers | tr ':' '\\n' )
ECDHE-RSA-AES256-GCM-SHA384
ECDHE-ECDSA-AES256-GCM-SHA384
ECDHE-RSA-AES256-SHA384
ECDHE-ECDSA-AES256-SHA384
ECDHE-RSA-AES256-SHA
ECDHE-ECDSA-AES256-SHA
DHE-RSA-AES256-GCM-SHA384
DHE-RSA-AES256-SHA256
DHE-RSA-AES256-SHA
ECDHE-RSA-AES128-GCM-SHA256
ECDHE-ECDSA-AES128-GCM-SHA256
ECDHE-RSA-AES128-SHA256
ECDHE-ECDSA-AES128-SHA256
ECDHE-RSA-AES128-SHA
ECDHE-ECDSA-AES128-SHA
DHE-RSA-AES128-GCM-SHA256
DHE-RSA-AES128-SHA256
DHE-RSA-AES128-SHA
"""
    )
}}

If you didn't get any results, you should probably spend the few days necessary to move everything to a platform at least from the last decade. Or maybe `openssl` didn't get set up correctly.

Unfortunately, this doesn't retain the order Qualys uses, and I've yet to figure out a good way to maintain the original order. A standard `bash` approach would be to `comm`pare the two lists, but `comm` expects the lists to be sorted.

{{
    shell_session("""\
$ comm -12 /save/the/qualys/list/somewhere <( openssl ciphers | tr ':' '\\n' )
comm: file 1 is not in sorted order
ECDHE-RSA-AES256-GCM-SHA384
comm: file 2 is not in sorted order
ECDHE-RSA-AES256-SHA384
$ comm --nocheck-order -12 /save/the/qualys/list/somewhere <( openssl ciphers | tr ':' '\\n' )
ECDHE-RSA-AES256-GCM-SHA384
ECDHE-RSA-AES256-SHA384
"""
    )
}}

Brace expansion doesn't reduce the size by much, so I gave up after a few hours on that tangent. However, the important thing is that you now know what ciphers are available for you to use that also have the Qualys stamp of approval.


{% endblock %}
